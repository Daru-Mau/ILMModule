\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{graphicx} 
\usepackage{import}
\usepackage{imakeidx} 
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{pdfpages}
\usepackage{array}
\usepackage{float} 
\usepackage{multicol}
\usepackage{listings} 
\usepackage{url}
\usepackage{natbib}
\usepackage{csquotes}
\usepackage{caption}
\usepackage{xcolor}   
\usepackage{geometry}

\geometry{top=25mm, bottom=25mm, left=20mm, right=20mm}
\setlength{\parindent}{0pt}
\renewcommand\contentsname{Index}

\begin{document}

\newpage
\clearpage
\import{./}{cover.tex}
\tableofcontents

\newpage
\section{Introduction}

As artificial intelligence continues to evolve, so too does the field of robotics, where machines not only think but also move, respond, and even emote. A growing subfield within this domain is that of \textit{social robots}---machines designed to interact with humans on a social level. These robots are increasingly taking on human-like forms, raising fundamental questions: Why must robots resemble us? Are we designing machines to mirror ourselves, or reshaping ourselves in their image?

\subsection{The Case for Humanlike Robots}

Social robots are distinct from industrial or task-specific robots. Their primary function is relational, not mechanical. Examples like Pepper \citep{pepperSoftbank} and Paro \citep{paro2003} illustrate how humanoid or animal-like forms are used to encourage emotional connection. This trend toward anthropomorphism reflects both a technological goal and a psychological strategy: humans are more likely to empathize with entities that resemble themselves \citep{dautenhahn2007}.

\subsection{Embodiment and Philosophical Underpinnings}

To understand the human-like design of robots, we must consider the philosophy of \textit{embodiment}. Philosophers like Merleau-Ponty and Johnson argue that intelligence and emotion are not purely cognitive but emerge through bodily experience \citep{merleau1962, johnson2007}.
Giving robots human bodies is not only about appearance—it is about replicating how humans experience the world through posture, gesture, and physical presence.

\subsection{The Uncanny Valley and Ethical Concerns}

The uncanny valley, a concept introduced by Masahiro Mori \citep{mori2012uncanny}, describes the discomfort people feel when a robot is almost—but not quite—human. Philosopher Sherry Turkle warns of the ethical risks of emotionally evocative robots that simulate empathy but do not truly feel \citep{turkle2011}. These “relational artifacts” may undermine authentic human connection by replacing mutual recognition with simulation.

\subsection{Non-Humanoid Social Robots}

Not all social robots are designed to resemble humans. Robots like Jibo and Kuri rely on motion, sound, and timing to express sociality \citep{jibo, kuri}. These robots show that social interaction can emerge from patterns of responsiveness rather than anatomy. This approach aligns with Levinas’ view that ethical relations stem from otherness, not similarity \citep{levinas1969}. A robot that looks alien may foster more honest interactions by avoiding deceptive familiarity.

\subsection{Symbolism Over Mimicry}

Non-humanoid robots draw on abstraction, using animation, light, and sound to evoke emotions. Rather than mimicking humans, they invite interpretive engagement—similar to how art, dance, or music operates. In this model, social interaction becomes metaphorical, poetic, and symbolic rather than literal.

\subsection{Embodiment Beyond the Human Form}

Embodiment, in robotic terms, is about meaningful physical interaction. A robot need not have a human body to be embodied. What matters is the feedback loop between perception and action \citep{dreyfus2002}. Social intelligence arises from engagement, not appearance.

\subsection{Course Project: Social Robot Design at Politecnico di Milano}

This paper draws on a practical design experience from the \textit{Robotics \& Design} course at Politecnico di Milano, taught by Professors Andrea Bonarini and Romero Maximiliano Ernesto. The class was divided into two teams: Indoor and Outdoor robot development. Each team was further subdivided. This paper focuses on the \textit{Localization Module}, which dealt with robot mobility and spatial awareness.
Their work illustrates how embodiment and social function are deeply intertwined—not only in theory, but in engineering practice.

\subsection{Conclusion}

Humanoid social robots attempt to simulate human interaction, but often blur the line between simulation and reality. Non-humanoid robots challenge anthropocentric design and promote more ethical, imaginative forms of engagement. As robots become companions, coworkers, and caregivers, their form is not just a design choice—it is a philosophical one.

\subsection*{References}
\bibliographystyle{plainnat}
\bibliography{socialrobots}

\newpage
\section{Functionalities}
\subsection{Module Functionalities}
\subsection{Flowcharts}
\begin{figure}[H]
    \centering
    \includegraphics[width=.35\linewidth]{photos/flowchart.jpeg}
\end{figure}


\newpage
\section{Omnidirectional robot: the idea behind} %Pros and cons, omniwheel logic and mechanics
An \textbf{omnidirectional robot} is a mobile robotic platform capable of independent translation along both the $x$ and $y$ axes and rotation about the vertical $z$ axis. This configuration allows for full planar mobility, enabling the robot to move in any direction without reorientation. Such robots are said to exhibit \textit{holonomic motion}, as they possess as many controllable degrees of freedom (DOF) as they have mobility constraints (3 DOF: $v_x$, $v_y$, and $\omega_z$).

\subsection{Omniwheel Configuration}

The key component enabling this kind of motion is the \textbf{omniwheel}—a wheel fitted with passive rollers around its circumference. These rollers are typically mounted at $90^\circ$ to the wheel's primary rotation plane, allowing the wheel to roll forward while permitting lateral movement.

In this section, we analyze a robot with a symmetric three-wheel omniwheel configuration, where the wheels are placed $120^\circ$ apart on an equilateral triangular chassis.

\subsection{Kinematic Modeling}

Let:
\begin{itemize}
    \item $r$ be the radius of each wheel.
    \item $R$ be the distance from the robot's center to each wheel.
    \item $\omega_i$ be the angular velocity of wheel $i$.
    \item $v_x, v_y$ be the robot's linear velocities in the body frame.
    \item $\omega_z$ be the angular (rotational) velocity of the robot.
\end{itemize}

\subsubsection{Forward Kinematics}

The relationship between the robot’s velocity vector and the individual wheel velocities is expressed as:

\[
\begin{bmatrix}
\omega_1 \\
\omega_2 \\
\omega_3
\end{bmatrix}
= \frac{1}{r}
\begin{bmatrix}
-\sin(\alpha_1) & \cos(\alpha_1) & R \\
-\sin(\alpha_2) & \cos(\alpha_2) & R \\
-\sin(\alpha_3) & \cos(\alpha_3) & R \\
\end{bmatrix}
\begin{bmatrix}
v_x \\
v_y \\
\omega_z
\end{bmatrix}
\]

For a symmetric configuration, the wheel placement angles are:
\[
\alpha_1 = 0^\circ, \quad \alpha_2 = 120^\circ, \quad \alpha_3 = 240^\circ
\]

Thus, the configuration matrix becomes:

\[
A =
\begin{bmatrix}
0 & 1 & R \\
-\frac{\sqrt{3}}{2} & -\frac{1}{2} & R \\
\frac{\sqrt{3}}{2} & -\frac{1}{2} & R \\
\end{bmatrix}
\]

Therefore, the wheel velocities are:

\[
\vec{\omega} = \frac{1}{r} A
\begin{bmatrix}
v_x \\
v_y \\
\omega_z
\end{bmatrix}
\]

\subsubsection{Inverse Kinematics}

Given the wheel angular velocities $\omega_1, \omega_2, \omega_3$, the robot’s motion in the body frame can be retrieved using:

\[
\begin{bmatrix}
v_x \\
v_y \\
\omega_z
\end{bmatrix}
= r A^+ 
\begin{bmatrix}
\omega_1 \\
\omega_2 \\
\omega_3
\end{bmatrix}
\]

where $A^+$ is the Moore–Penrose pseudoinverse of matrix $A$.

\subsection{Mechanical Considerations}

\subsubsection{Load and Stability}

The chassis is typically triangular or circular, ensuring symmetric load distribution. The robot’s center of mass (COM) should ideally be centered with respect to the wheelbase to prevent slipping or tipping, particularly during acceleration or rotation. This topic will be further explored in the following section, where the shape will be discuss and the design choiches explained.

\subsubsection{Traction and Friction}

Each omniwheel translates drive torque in its rolling direction while passively allowing orthogonal motion via its rollers. The use of omniwheels eliminates lateral traction constraints, although it may introduce some slip during rapid maneuvers or uneven loading.

\subsubsection{Torque Requirements}

Assuming a robot mass $m$ and target linear acceleration $a$, the required torque per motor is approximately:

\[
\tau = \frac{m a r}{3}
\]

This assumes equal load sharing and negligible frictional losses. Further and specific calculus will be given and formulated in the section related to Engine and mechanics, where also the engine functions will be introduced.

\subsubsection{Encoder-Based Odometry}

Rotary encoders on each motor measure $\omega_i$, enabling estimation of the robot’s pose through dead-reckoning. However, odometric drift accumulates over time, necessitating external correction methods such as vision-based localization or SLAM.

\subsection{Dynamic Model (Optional)}

For dynamic control strategies such as model predictive control (MPC), a dynamic model considering the robot's mass and inertia tensor is needed:

\[
M \cdot \ddot{\mathbf{q}} = J^T \cdot \mathbf{F}
\]

Where:
\begin{itemize}
    \item $M$ is the mass/inertia matrix.
    \item $J$ is the Jacobian relating wheel velocities to robot motion.
    \item $\mathbf{F}$ is the vector of wheel forces.
    \item $\ddot{\mathbf{q}} = [\ddot{x}, \ddot{y}, \ddot{\theta}]^T$ is the acceleration vector.
\end{itemize}

This model enables the computation of required motor torques to follow a specific trajectory, accounting for physical dynamics.

\subsection{Advantages of the 3-Wheel Omni Design}

\begin{itemize}
    \item Fully holonomic motion using only three motors.
    \item Mechanically simpler than 4-Mecanum designs.
    \item Ideal for flat indoor surfaces and lab environments.
    \item Easier software implementation due to symmetry.
\end{itemize}

\noindent This configuration is widely used in research platforms, service robots, and competitive robotics where agility and precision are required in confined spaces. 

\subsection{The Omni design: the project and the design drivers}
\noindent
\begin{minipage}[t]{0.6\textwidth}
  \vspace{0pt}
  \includegraphics[width=\linewidth]{photos/omnirob.png}
  \captionof{figure}{three-wheel Omnidirectional}
\end{minipage}
\hfill
\begin{minipage}[t]{0.4\textwidth}
    \vspace{0pt}
    In relation to the functionalities defined during our brainstorming sessions, our attention was drawn to a model presented by Professor Bonarini during one of his lectures.
    The robot, as illustrated in Figure 1, represents an evolution of the synchronous drive system.
    It employs at least three Swedish wheels, which are capable of both rolling and translating sideways. Each wheel is equipped with an independent motor and is oriented in a different direction.
    Thanks to this configuration, the robot can rotate while moving, enabling fully omnidirectional motion. \\

    An omnidirectional robot comes with its own set of challenges. After presenting a paperboard prototype, Professor Romero raised concerns about stability and wheel configuration: "Why three wheels? With four, it's more stable." This prompted the team to gather and reflect on the question, considering all potential consequences for the other teams and the project as a whole. An impulsive choice could have compromised the entire effort. \\

    \end{minipage}
    
    We initiated a video call with the goal of brainstorming the issue. Pros and cons of the two main configurations were discussed and formalized. Perhaps the most important insight we gained from that conversation was identifying the drivers—the key variables guiding our decisions. These drivers, combined with \textbf{Available Time}, would go on to shape our approach throughout the rest of the project: 

    \begin{enumerate}
        \item Financial Considerations — It is not appropriate to proceed with purchases based solely on the assumption that individuals will be able to afford them. Such an approach fails to take into account the diverse financial situations of team members and may be perceived as inconsiderate or disrespectful.
        \item Weight Considerations — Each component contributes not only to the overall weight of the system, but also to its structural integrity and center of gravity. It was therefore crucial to recognize that even minor modifications could significantly affect the overall design, potentially necessitating recalculations and, consequently, the adoption of more powerful motors or alternative components. Such changes could trigger a cascading effect, resulting in a continuous cycle of specification redefinition and system redesign.
        \item Power Consumption — The energy requirements of each component had to be carefully evaluated in order to ensure overall system efficiency and autonomy. Excessive power consumption could compromise the robot’s operational time, increase the need for larger and heavier batteries, and introduce additional thermal management challenges. As a result, power efficiency became a critical factor influencing both component selection and architectural decisions throughout the design process.
    \end{enumerate}

    Conclusion: The more precisely a problem is formulated and modeled, the more calculations and simulations can be performed, thus reducing the likelihood of critical errors in the final product. We ultimately chose the three-wheel configuration, considering the low speed required by our robot, the reduced number of motors and sensors (resulting in lower power consumption, weight, and cost), and the design challenge posed by the shape. This decision also encouraged us to think creatively, steering away from the conventional four-wheel vehicle design and distancing ourselves from the idea of a simple toy or child’s car.

\newpage
\section{Structure design} %and how elechtronics will be divided
\subsection{Single pieces design}
\begin{figure}[H]
    \centering
    \includegraphics[width=.9\linewidth]{technical_drawings/base_robot_tavola.pdf}
    \caption{Modello assemblato}
    \label{fig:base_robot_tavola}
\end{figure}

\newpage
\begin{figure}[H]
    \centering
    \includegraphics[width=.9\linewidth]{technical_drawings/12_piccolo sopra.pdf}
    \caption{Superior Base}
    \label{fig:12_piccolo_sopra}
\end{figure}

\newpage
\begin{figure}[H]
    \centering
    \includegraphics[width=.9\linewidth]{technical_drawings/mattone_sopra.pdf}
    \caption{Support brick}
    \label{fig:mattone_sopra}
\end{figure}

\newpage
\begin{figure}[H]
    \centering
    \includegraphics[width=.9\linewidth]{technical_drawings/colonna.pdf}
    \caption{Support column}
    \label{fig:colonna}
\end{figure}

\newpage
\begin{figure}[H]
    \centering
    \includegraphics[width=.9\linewidth]{technical_drawings/12_grande.pdf}
    \caption{Inter-level Base}
    \label{fig:12_grande}
\end{figure}

\newpage
\begin{figure}[H]
    \centering
    \includegraphics[width=.9\linewidth]{technical_drawings/mattone_sotto.pdf}
    \caption{Intra-level brick}
    \label{fig:mattone_sotto}
\end{figure}

\newpage
\begin{figure}[H]
    \centering
    \includegraphics[width=.9\linewidth]{technical_drawings/12_base.pdf}
    \caption{Inferior Base}
    \label{fig:12_base}
\end{figure}


\newpage
\section{Materials choice}
\begin{table}[H]
\centering
\begin{tabular}{|p{3cm}|p{2.2cm}|p{2.5cm}|p{2cm}|p{5cm}|}
\hline
\textbf{Material} & \textbf{Density (kg/m$^3$)} & \textbf{Young's Modulus (GPa)} & \textbf{Cost (\$/kg)} & \textbf{Notes} \\ \hline
Aluminum 6061       & 2700  & 69   & 3.0    & Lightweight, corrosion resistant \\ \hline
MDF (Medium Density Fiberboard) & 700   & 4    & 0.5    & Easy to machine, low-cost \\ \hline
ABS Plastic         & 1050  & 2.1  & 2.5    & Good impact resistance \\ \hline
Carbon Fiber Reinforced Polymer & 1600  & 70   & 60     & High strength-to-weight ratio \\ \hline
PLA (Polylactic Acid) & 1240 & 3.5  & 1.8    & 3D printable, biodegradable \\ \hline
Steel (AISI 1018)   & 7850  & 210  & 0.9    & High strength, heavy \\ \hline
Titanium Alloy (Ti-6Al-4V) & 4430 & 113 & 30    & Extremely strong, corrosion resistant \\ \hline
Plywood             & 600   & 10   & 0.4    & Stronger than MDF, lightweight \\ \hline
Nylon 6             & 1140  & 2.8  & 2.2    & Tough and flexible \\ \hline
Polycarbonate       & 1200  & 2.4  & 3.0    & High impact resistance, transparent \\ \hline
\end{tabular}
\caption{Selected Materials for Robot Construction}
\label{tab:materials}
\end{table}


\noindent
In Table~\ref{tab:materials}, we show every possible material taken into consideration for the construction of the robot's structure. Each material is listed along with its density, Young's modulus, and estimated cost per kilogram. The density impacts the overall weight of the robot, influencing both mobility and energy consumption. Young's modulus, a measure of stiffness, indicates how much a material resists deformation under stress: materials with a higher Young's modulus, such as steel or carbon fiber composites, deform very little and are ideal for structural components requiring rigidity. Conversely, materials like MDF or ABS offer easier machining and lower costs at the expense of mechanical strength. The choice of material must balance mechanical properties, ease of manufacturing, and budget constraints, depending on the specific requirements of the robotic application.


\newpage
\section{Engine and mechanics} %Motors, motor drivers, wheels and shaft
\textbf{Motors, motor drivers, wheels and shafts}
As previously discussed and presented in the omnidirectional robot section, the required wheels to achieve the full potential of movement are particular. Mecanum wheels or omni wheels are commonly used in such applications. These wheels allow the robot to move not only forward and backward, but also sideways and diagonally, enabling a full range of motion without the need for complex steering mechanisms. Mecanum wheels achieve this by using rollers mounted at a 45-degree angle around the wheel's circumference, whereas omni wheels utilize free-spinning rollers aligned perpendicular to the wheel's rotation. Both designs significantly enhance maneuverability, making them ideal for robotics projects where space constraints, precise movement, and agility are critical factors.
\\

The choice between mecanum and omni wheels depends on the specific application requirements, including the load capacity, desired speed, and surface conditions. Mecanum wheels are typically preferred for heavier payloads and fully omnidirectional drive systems, while omni wheels are often lighter and simpler, suited for smaller robots or specialized movement configurations.
\\

\noindent
\begin{minipage}[t]{0.4\textwidth}
  \vspace{0pt}
  \includegraphics[width=0.8\linewidth]{photos/wheel.jpg}
\end{minipage}
\hfill
\begin{minipage}[t]{0.6\textwidth}
    \vspace{0pt}
    Considering the primary driver behind our design decisions — namely, budget constraints — we opted for the omni wheel solution. The specific model selected, with the guidance of Professor Bonarini, features free-spinning rollers mounted on axes. A critical specification of these wheels, which significantly influenced the overall design of the robot, is their maximum load capacity of 15 kg. \\

    The shafts were already included in our selected wheel model, slightly simplifying our work. Although the 15 kg load limitation was initially seen as a drawback, it actually allowed us to breathe a sigh of relief, since until then we had no clear idea of how much weight our motors would need to move. Given that the other modules were developed independently from ours, no one had a precise understanding of the total weight of the final robot, nor of the motor power requirements. Thus, this load capacity specification turned out to be the first of three key parameters that enabled the team to calculate the necessary technical specifications for the motors. \\
\end{minipage}

So, the maximum robot weight was established at 15 kg, but what about speed and acceleration? Thanks to previous university courses taken during our bachelor's degree, we knew that calculating the required motor specifications would also require defining both the desired speed and acceleration. However, at that stage, everything was still uncertain: the robot's functionalities were not yet fully defined, and we had little information to work with. As a result, we had to remain patient and wait for further developments. Finally, after a backbone meeting, all the different pieces started to come together, allowing us to begin reasoning about possible specifications and move forward with the motor selection process. \\

Considering the main functionalities — namely, staying near the microwave area and interacting with people — our module assumed a rather secondary role within the overall project. The idea of "dancing" following user interaction, autonomously moving to and from the charging station, and detecting occasional obstacles led us to intentionally limit both the "intelligence" of our module and its kinematic performance. There was no need to achieve an acceleration of 1 m/s\textsuperscript{2}; an acceleration of 0.5 m/s\textsuperscript{2} was deemed more than sufficient (and arguably even excessive for our purposes). Similarly, a maximum speed of 1.5 m/s was considered more than adequate, as there was no requirement to keep pace with human users. At this stage, the project was starting to take on a more realistic dimension, pushing us to optimize our design choices in line with the identified drivers and project constraints.

\subsection{DC motors}

DC (Direct Current) motors operate based on the fundamental principle of electromagnetism. The core components and processes involved in the functioning of DC motors can be explained as follows:

\begin{enumerate}
    \item \textbf{Armature (Rotor)}: The armature is the rotating part of the DC motor, typically a coil wound with wire (usually copper). This part is positioned within a magnetic field and is connected to the motor's shaft.
    
    \item \textbf{Stator (Magnetic Field)}: The stator creates a magnetic field in which the armature rotates. This field can be generated using either permanent magnets or electromagnets (field windings). The magnetic field can be constant or varying depending on the motor's design.
    
    \item \textbf{Commutator}: The commutator is a rotary switch that reverses the current direction in the armature windings at the correct moments to ensure continuous rotation. It works in tandem with the carbon brushes to maintain a proper current path to the armature.
    
    \item \textbf{Brushes}: The brushes, made of carbon or graphite, are in constant contact with the commutator. They provide a conductive path for current to flow into the armature windings during rotation. The brushes are essential for transferring power to the rotating armature.
    
    \item \textbf{Power Supply}: The motor operates using a DC power supply that provides a continuous flow of current. The motor's speed is proportional to the supplied voltage, while the torque is determined by the current.
    
    \item \textbf{Lorentz Force}: When the current flows through the armature windings within the magnetic field, the interaction between the magnetic field and the current generates a force (according to Lorentz’s law) that causes the armature to rotate. The direction of rotation follows the right-hand rule, where the thumb points in the direction of the current, the fingers in the direction of the magnetic field, and the palm in the direction of the force.
\end{enumerate}

  \includegraphics[width=.7
    \linewidth]{photos/dc-motor-diagram.jpg}
    
DC motors are frequently chosen for mobile robotic applications, particularly for tasks involving movement and localization. Below are the reasons for their suitability for such tasks:

\begin{enumerate}
    \item \textbf{Precise Speed and Position Control}: DC motors offer straightforward and continuous speed control. By adjusting the input voltage or using Pulse Width Modulation (PWM), the motor’s speed can be efficiently controlled. Additionally, the use of encoders or tachometers attached to the motor's shaft provides position and velocity feedback, which is essential for precise movement control in robots.
    
    \item \textbf{Simplicity and Cost-Effectiveness}: DC motors are simpler in design compared to AC motors or stepper motors, making them cost-effective. The simplicity also leads to easier integration with control systems for robotic movement, which is crucial in social robots designed for cost-effective consumer applications.
    
    \item \textbf{High Torque at Low Speeds}: DC motors provide high torque at low speeds, which is crucial for precise movements and overcoming resistances such as friction or obstacles. Social robots require smooth, controlled movement to operate safely and effectively in environments shared with humans.
    
    \item \textbf{Compact Design}: DC motors are generally compact and lightweight, making them well-suited for robots that must maintain a small footprint. This is especially important for social robots that are designed to operate in tight spaces, such as homes or offices.
    
    \item \textbf{Smooth and Continuous Operation}: DC motors provide smooth and continuous rotation, which is essential for robots that must interact with humans in a non-disruptive manner. Smooth motion is necessary for both navigating environments and interacting with people.
    
    \item \textbf{Easy Reversal of Direction}: Changing the direction of motion in a DC motor is straightforward by simply reversing the polarity of the power supply. This ability is critical for localization and navigation tasks where the robot may need to quickly change direction or reorient itself.
    
    \item \textbf{Adaptability in Differential Drive Systems}: DC motors are commonly used in differential drive systems, where two wheels are independently driven by separate motors. This configuration allows for agile movement in any direction, a key advantage for robots needing to navigate dynamic environments and avoid obstacles.
    
    \item \textbf{Energy Efficiency}: While not the most energy-efficient compared to stepper motors, DC motors can still deliver an adequate level of efficiency when optimized for low power consumption. This makes them suitable for robots that need to operate autonomously for extended periods in environments like homes and offices.
\end{enumerate}


DC motors are ideal for use in the localization and movement modules of social robots due to their simplicity, precision, cost-effectiveness, high torque, and the ability to easily reverse direction. These characteristics enable precise control of the robot's movement, making it suitable for dynamic environments where smooth and controlled motion is critical. With their versatility, DC motors allow for effective interaction and navigation, ensuring that social robots can function efficiently in everyday human environments.


\subsection{The math behind}

One major flaw of the omniwheel configuration is that there will never be the situation where all the combined torque will be used. In the 120 degrees configuration, a wheel is always stationary with just the rullers spinning.

\newpage
\section{Controllers and sensors choice} %digital pin, arduino and elego presentation

\newpage
\section{The electronic behind} %how the connection works, how the signals works 

\newpage
\subsection{KiCad schematics}
\begin{figure}[H]
    \centering
    \rotatebox{90}{\includegraphics[width=.99\linewidth]{pfds/IL_schema.pdf}}
\end{figure}


\subsection{I2C for intra-communications} %how communication between modulus works

\newpage
\section{Software Architecture}
\subsection{System Overview}
The robot's software architecture follows a modular design with clear separation of concerns:

\begin{itemize}
    \item \textbf{AprilTag Recognition (Python)}
        \begin{itemize}
            \item Camera-based tag detection using OpenCV
            \item Real-time pose estimation
            \item Communication with Arduino through Serial
        \end{itemize}
    
    \item \textbf{Communication Layer (Python)}
        \begin{itemize}
            \item Reliable serial communication protocol
            \item Error handling and retry mechanisms
            \item Status monitoring and reporting
        \end{itemize}
    
    \item \textbf{Localization System (Arduino)}
        \begin{itemize}
            \item Sensor fusion from multiple sources
            \item Position and orientation tracking
            \item AprilTag-based corrections
        \end{itemize}
    
    \item \textbf{Movement Control (Arduino)}
        \begin{itemize}
            \item Fine-grained motor control
            \item Holonomic movement calculations
            \item Obstacle avoidance
        \end{itemize}
\end{itemize}

\subsection{Communication Protocol}
The system uses a standardized communication protocol between components:

\begin{itemize}
    \item \textbf{Tag Detection Messages:} \texttt{TAG:id,x,y,yaw}
    \item \textbf{Position Updates:} \texttt{POS:x,y,theta}
    \item \textbf{Control Commands:} Single-character commands (M, T, S, R)
    \item \textbf{Status Reports:} Regular updates of system state
\end{itemize}

\subsection{Control Modes}
The robot operates in several distinct modes:

\begin{enumerate}
    \item \textbf{MANUAL}: Direct control through serial commands
    \item \textbf{AUTONOMOUS}: Independent navigation with obstacle avoidance
    \item \textbf{TAG\_FOLLOWING}: AprilTag-based target tracking
    \item \textbf{CHARGING}: Automated docking with charging station
\end{enumerate}

\newpage
\section{Implementation Details}
\subsection{Core Components}

\subsubsection{AprilTag Detection System}
The vision system uses OpenCV and the pupil-apriltags library for reliable tag detection:
\begin{itemize}
    \item Real-time image processing at 30 FPS
    \item Sub-pixel corner detection for improved accuracy
    \item 6-DOF pose estimation
    \item Automatic camera calibration handling
\end{itemize}

\subsubsection{Navigation Controller}
The navigation system implements:
\begin{itemize}
    \item Real-time obstacle detection and avoidance
    \item Dynamic path planning
    \item Multiple control modes with smooth transitions
    \item Emergency stop functionality
\end{itemize}

\subsubsection{Motor Control System}
The motor control implementation features:
\begin{itemize}
    \item Smooth acceleration and deceleration with direction preservation
    \item Dynamic speed adjustment based on obstacles
    \item Precise holonomic movement control
    \item Emergency stop with motor braking
\end{itemize}

\subsection{System Integration}
The components are integrated through:
\begin{itemize}
    \item High-speed serial communication (115200 baud)
    \item Standardized message protocols
    \item Regular status updates (20Hz)
    \item Error detection and recovery mechanisms
\end{itemize}

\subsection{Performance Characteristics}
The integrated system achieves:
\begin{itemize}
    \item Position accuracy: ±5mm in controlled conditions
    \item Heading accuracy: ±2 degrees with IMU fusion
    \item Maximum safe speed: 0.5 m/s
    \item Control loop frequency: 20Hz
    \item Tag detection rate: 30 FPS
    \item Emergency stop response: <100ms
\end{itemize}

\subsection{Safety Features}
Built-in safety mechanisms include:
\begin{itemize}
    \item Multi-level obstacle detection
    \item Emergency stop functionality
    \item Motor current monitoring
    \item Sensor validation checks
    \item Fail-safe operation modes
\end{itemize}

\newpage
\section{Testing and Validation}
\subsection{Component Testing}
Each component underwent rigorous testing:

\subsubsection{Vision System}
\begin{itemize}
    \item Tag detection reliability in various lighting
    \item Pose estimation accuracy
    \item Frame rate consistency
    \item Camera calibration stability
\end{itemize}

\subsubsection{Navigation System}
\begin{itemize}
    \item Obstacle avoidance effectiveness
    \item Path planning accuracy
    \item Mode switching reliability
    \item Emergency stop response time
\end{itemize}

\subsubsection{Motor Control}
\begin{itemize}
    \item Movement precision
    \item Speed control accuracy
    \item Acceleration profile smoothness
    \item Power consumption monitoring
\end{itemize}

\subsection{Integration Testing}
System-wide integration testing validated:
\begin{itemize}
    \item Component communication reliability
    \item System response to various scenarios
    \item Error handling effectiveness
    \item Overall system stability
\end{itemize}

\newpage
\section{Future Improvements}
Potential enhancements include:
\begin{itemize}
    \item Implementation of SLAM for improved mapping
    \item Enhanced sensor fusion algorithms
    \item Machine learning for obstacle avoidance
    \item Wireless control interface
    \item Advanced path planning algorithms
    \item Battery management system
\end{itemize}

\newpage
\section{The software behind} %How the code is injected
\newpage
\subsection{HC-SR04 testing}
The following code represents our initial testing of six HC-SR04 ultrasonic sensors. The objective was to verify reliable distance measurements from each sensor by checking the readings when placing obstacles at various distances. Here's the implementation:

\begin{lstlisting}[language=C, basicstyle=\ttfamily\footnotesize, frame=single, xleftmargin=10mm, xrightmargin=10mm]
const int trigPins[6] = {2, 4, 6, 8, 10, 12}; // Trigger pins for 6 sensors
const int echoPins[6] = {3, 5, 7, 9, 11, 13}; // Echo pins for 6 sensors

long distances[6]; // Array to store distance readings

void setup() {
  Serial.begin(9600);

  // Initialize pins
  for (int i = 0; i < 6; i++) {
    pinMode(trigPins[i], OUTPUT);
    pinMode(echoPins[i], INPUT);
  }
}

void loop() {
  for (int i = 0; i < 6; i++) {
    distances[i] = readDistance(trigPins[i], echoPins[i]);
  }

  for (int i = 0; i < 6; i++) { // Print all distances
    Serial.print("Sensor");
    Serial.print(i + 1);
    Serial.print(":");
    Serial.print(distances[i]);
    Serial.println("cm");
  }

  Serial.println("------------------------");
  delay(500);  // Wait before next reading
}

// Function to read distance from one HC-SR04
long readDistance(int trigPin, int echoPin) {
  digitalWrite(trigPin, LOW);
  delayMicroseconds(2);
  digitalWrite(trigPin, HIGH);
  delayMicroseconds(10);
  digitalWrite(trigPin, LOW);

  long duration = pulseIn(echoPin, HIGH, 30000); // Timeout at 30 ms
  long distance = duration * 0.034 / 2; // Convert to cm
  
  if (distance == 0 || distance > 400) {
    return -1;  // Invalid reading
  }
  return distance;
}
\end{lstlisting}

\subsection{Engines and HC-SR04 Integration}
The following code represents our implementation of the holonomic drive system integrated with ultrasonic sensors for obstacle detection:

\begin{lstlisting}[language=C, basicstyle=\ttfamily\footnotesize, frame=single, xleftmargin=10mm, xrightmargin=10mm]
// === HolonomicDrive Class ===

class HolonomicDrive {
public:
    HolonomicDrive(int rF, int lF, int enF, int rL, int lL, 
    int enL, int rR, int lR, int enR) {
        // Assign motor pins
        RPWM_RIGHT = rF;
        LPWM_RIGHT = lF;
        EN_RIGHT = enF;
        RPWM_LEFT = rL;
        LPWM_LEFT = lL;
        EN_LEFT = enL;
        RPWM_BACK = rR;
        LPWM_BACK = lR;
        EN_BACK = enR;

        // Set motor pins as outputs
        int pins[] = { RPWM_RIGHT, LPWM_RIGHT, EN_RIGHT,
                       RPWM_LEFT, LPWM_LEFT, EN_LEFT,
                       RPWM_BACK, LPWM_BACK, EN_BACK };

        for (int i = 0; i < 9; i++) {
            pinMode(pins[i], OUTPUT);
        }

        enableMotors();
    }

    void enableMotors() {
        digitalWrite(EN_RIGHT, HIGH);
        digitalWrite(EN_LEFT, HIGH);
        digitalWrite(EN_BACK, HIGH);
    }

    void moveForward(int speed) {
        moveMotor(RPWM_RIGHT, LPWM_RIGHT, speed);
        moveMotor(RPWM_LEFT, LPWM_LEFT, speed);
        moveMotor(RPWM_BACK, LPWM_BACK, speed);
    }

    void moveBackward(int speed) {
        moveMotorBackward(RPWM_RIGHT, LPWM_RIGHT, speed);
        moveMotorBackward(RPWM_LEFT, LPWM_LEFT, speed);
        moveMotorBackward(RPWM_BACK, LPWM_BACK, speed);
    }

    void slideLeft(int speed) {
        moveMotor(RPWM_BACK, LPWM_BACK, speed);
        moveMotorBackward(RPWM_LEFT, LPWM_LEFT, speed);
        stopMotor(RPWM_RIGHT, LPWM_RIGHT);
    }

    void slideRight(int speed) {
        moveMotorBackward(RPWM_BACK, LPWM_BACK, speed);
        moveMotor(RPWM_LEFT, LPWM_LEFT, speed);
        stopMotor(RPWM_RIGHT, LPWM_RIGHT);
    }

    void rotateLeft(int speed) {
        moveMotorBackward(RPWM_RIGHT, LPWM_RIGHT, speed);
        moveMotor(RPWM_LEFT, LPWM_LEFT, speed);
        moveMotorBackward(RPWM_BACK, LPWM_BACK, speed);
    }

    void rotateRight(int speed) {
        moveMotor(RPWM_RIGHT, LPWM_RIGHT, speed);
        moveMotorBackward(RPWM_LEFT, LPWM_LEFT, speed);
        moveMotor(RPWM_BACK, LPWM_BACK, speed);
    }

    void stopAll() {
        stopMotor(RPWM_RIGHT, LPWM_RIGHT);
        stopMotor(RPWM_LEFT, LPWM_LEFT);
        stopMotor(RPWM_BACK, LPWM_BACK);
    }

private:
    int RPWM_RIGHT, LPWM_RIGHT, EN_RIGHT;
    int RPWM_LEFT, LPWM_LEFT, EN_LEFT;
    int RPWM_BACK, LPWM_BACK, EN_BACK;

    void moveMotor(int rpwm, int lpwm, int speed) {
        analogWrite(rpwm, speed);
        analogWrite(lpwm, 0);
    }

    void moveMotorBackward(int rpwm, int lpwm, int speed) {
        analogWrite(rpwm, 0);
        analogWrite(lpwm, speed);
    }

    void stopMotor(int rpwm, int lpwm) {
        analogWrite(rpwm, 0);
        analogWrite(lpwm, 0);
    }
};

// === Pin Definitions ===

// Ultrasonic Sensors
const int TP_FRONT = 22, EP_FRONT = 23;
const int TP_FRONT_LEFT = 24, EP_FRONT_LEFT = 25;
const int TP_FRONT_RIGHT = 26, EP_FRONT_RIGHT = 27;
const int TP_LEFT = 28, EP_LEFT = 29;
const int TP_RIGHT = 30, EP_RIGHT = 31;
const int TP_BACK = 32, EP_BACK = 33;

// Motor Driver Pins
const int RPWM_RIGHT = 37, LPWM_RIGHT = 36, REN_RIGHT = 39, LEN_RIGHT = 38;
const int RPWM_LEFT = 43, LPWM_LEFT = 42, REN_LEFT = 45, LEN_LEFT = 44;
const int RPWM_BACK = 49, LPWM_BACK = 48, REN_BACK = 51, LEN_BACK = 50;

// Encoder Pins
const int ENCODER_FRONT_A = 33;
const int ENCODER_FRONT_B = 32;

// === Globals ===
float distFront, distFrontLeft, distFrontRight, distLeft, distRight, distBack;
const float OBSTACLE_DISTANCE = 10.0;  // cm

// === Setup ===

void setup() {
    Serial.begin(9600);

    int trigPins[] = { TP_FRONT, TP_FRONT_LEFT, TP_FRONT_RIGHT, 
    TP_LEFT, TP_RIGHT, TP_BACK };
    int echoPins[] = { EP_FRONT, EP_FRONT_LEFT, EP_FRONT_RIGHT, 
    EP_LEFT, EP_RIGHT, EP_BACK };

    for (int i = 0; i < 6; i++) {
        pinMode(trigPins[i], OUTPUT);
        pinMode(echoPins[i], INPUT);
    }

    int motorPins[] = {
        RPWM_RIGHT, LPWM_RIGHT, REN_RIGHT, LEN_RIGHT,
        RPWM_LEFT, LPWM_LEFT, REN_LEFT, LEN_LEFT,
        RPWM_BACK, LPWM_BACK, REN_BACK, LEN_BACK
    };

    for (int i = 0; i < 12; i++) pinMode(motorPins[i], OUTPUT);

    digitalWrite(REN_RIGHT, HIGH);
    digitalWrite(LEN_RIGHT, HIGH);
    digitalWrite(REN_LEFT, HIGH);
    digitalWrite(LEN_LEFT, HIGH);
    digitalWrite(REN_BACK, HIGH);
    digitalWrite(LEN_BACK, HIGH);

    pinMode(ENCODER_FRONT_A, INPUT);
    pinMode(ENCODER_FRONT_B, INPUT);

    Serial.println("ROBOT READY");
}

// === Distance Sensing ===

float readDistance(int trigPin, int echoPin) {
    digitalWrite(trigPin, LOW);
    delayMicroseconds(2);
    digitalWrite(trigPin, HIGH);
    delayMicroseconds(10);
    digitalWrite(trigPin, LOW);

    long duration = pulseIn(echoPin, HIGH, 30000);
    return (duration <= 0) ? 999.0 : duration * 0.034 / 2;
}

void updateDistances() {
    distFront = readDistance(TP_FRONT, EP_FRONT);
    distFrontLeft = readDistance(TP_FRONT_LEFT, EP_FRONT_LEFT);
    distFrontRight = readDistance(TP_FRONT_RIGHT, EP_FRONT_RIGHT);
    distLeft = readDistance(TP_LEFT, EP_LEFT);
    distRight = readDistance(TP_RIGHT, EP_RIGHT);
    distBack = readDistance(TP_BACK, EP_BACK);
}

// === Motor Logic ===

void setMotor(int rpwm, int lpwm, int speed) {
    motorSpeed = constrain(motorSpeed, -255, 255);

    if (motorSpeed > 0) {
        analogWrite(rpwm, speed);
        analogWrite(lpwm, 0);
    } else {
        analogWrite(rpwm, 0);
        analogWrite(lpwm, -motorSpeed);
    }
}

// === Triskar Movement Logic ===

void moveRobot(float vx, float vy, float omega, int speed = 180) {
    float v_front = -vx + omega;
    float v_left = 0.5 * vx - 0.866 * vy + omega;
    float v_right = 0.5 * vx + 0.866 * vy + omega;

    float maxVal = max(max(abs(v_front), abs(v_left)), abs(v_right));

    if (maxVal > 1.0) {
        v_front /= maxVal;
        v_left /= maxVal;
        v_right /= maxVal;
    }

    setMotor(RPWM_RIGHT, LPWM_RIGHT, v_front * speed);
    setMotor(RPWM_LEFT, LPWM_LEFT, v_left * speed);
    setMotor(RPWM_BACK, LPWM_BACK, v_right * speed);
}

void stopAllMotors() {
    analogWrite(RPWM_RIGHT, 0);
    analogWrite(LPWM_RIGHT, 0);
    analogWrite(RPWM_LEFT, 0);
    analogWrite(LPWM_LEFT, 0);
    analogWrite(RPWM_BACK, 0);
    analogWrite(LPWM_BACK, 0);
}

// === Main Loop ===

void loop() {
    updateDistances();

    Serial.print("F: "); Serial.print(distFront);
    Serial.print(" FL: "); Serial.print(distFrontLeft);
    Serial.print(" FR: "); Serial.print(distFrontRight);
    Serial.print(" L: "); Serial.print(distLeft);
    Serial.print(" R: "); Serial.print(distRight);
    Serial.print(" B: "); Serial.println(distBack);

    if (distFront < OBSTACLE_DISTANCE || distFrontLeft < OBSTACLE_DISTANCE || 
    distFrontRight < OBSTACLE_DISTANCE) {
        Serial.println("Obstacle in front - rotating to avoid");
        if (distLeft > distRight) {
            moveRobot(0.0, 0.0, -1.0);
        } else {
            moveRobot(0.0, 0.0, 1.0);
        }
        delay(500);
        stopAllMotors();
    }
    else if (distLeft < OBSTACLE_DISTANCE) {
        Serial.println("Obstacle on left - sliding right");
        moveRobot(1.0, 0.0, 0.0);
        delay(400);
        stopAllMotors();
    }
    else if (distRight < OBSTACLE_DISTANCE) {
        Serial.println("Obstacle on right - sliding left");
        moveRobot(-1.0, 0.0, 0.0);
        delay(400);
        stopAllMotors();
    }
    else {
        Serial.println("Path is clear - moving forward");
        moveRobot(-1.0, 1.0, 0.0);
    }

    delay(200);
}
\end{lstlisting}

\subsection{Alpha script}
The alpha testing phase focused on validating the core functionality of individual components before full integration. Here's the implementation used for alpha testing:

\begin{lstlisting}[language=C, basicstyle=\ttfamily\footnotesize, frame=single, xleftmargin=10mm, xrightmargin=10mm]
class AlphaTest {
public:
    // Test modes
    enum TestMode {
        MOTOR_TEST,
        SENSOR_TEST,
        ENCODER_TEST,
        IMU_TEST,
        TAG_TEST
    };
    
    void runTest(TestMode mode) {
        switch(mode) {
            case MOTOR_TEST:
                testMotorSequence();
                break;
            case SENSOR_TEST:
                testSensors();
                break;
            case ENCODER_TEST:
                testEncoders();
                break;
            case IMU_TEST:
                testIMU();
                break;
            case TAG_TEST:
                testAprilTag();
                break;
        }
    }

private:
    void testMotorSequence() {
        // Test each motor individually
        Serial.println("Testing Front Motor");
        testSingleMotor(RPWM_RIGHT, LPWM_RIGHT);
        
        Serial.println("Testing Left Motor");
        testSingleMotor(RPWM_LEFT, LPWM_LEFT);
        
        Serial.println("Testing Back Motor");
        testSingleMotor(RPWM_BACK, LPWM_BACK);
        
        // Test combined movements
        Serial.println("Testing Forward Movement");
        moveRobot(-1.0, 0.0, 0.0, 150);
        delay(2000);
        stopAllMotors();
        
        Serial.println("Testing Rotation");
        moveRobot(0.0, 0.0, 1.0, 150);
        delay(2000);
        stopAllMotors();
    }
    
    void testSingleMotor(int rpwm, int lpwm) {
        // Forward
        analogWrite(rpwm, 150);
        analogWrite(lpwm, 0);
        delay(2000);
        
        // Stop
        analogWrite(rpwm, 0);
        analogWrite(lpwm, 0);
        delay(1000);
        
        // Backward
        analogWrite(rpwm, 0);
        analogWrite(lpwm, 150);
        delay(2000);
        
        // Stop
        analogWrite(rpwm, 0);
        analogWrite(lpwm, 0);
        delay(1000);
    }
    
    void testSensors() {
        int maxTests = 50;
        for(int i = 0; i < maxTests; i++) {
            updateDistances();
            printSensorData();
            delay(200);
        }
    }
    
    void testEncoders() {
        long startLeft = leftEncoderCount;
        long startRight = rightEncoderCount;
        
        // Move forward briefly
        moveRobot(-1.0, 0.0, 0.0, 150);
        delay(1000);
        stopAllMotors();
        
        // Check encoder counts
        Serial.print("Left Encoder Delta: ");
        Serial.println(leftEncoderCount - startLeft);
        Serial.print("Right Encoder Delta: ");
        Serial.println(rightEncoderCount - startRight);
    }
    
    void testIMU() {
        float startTheta = theta;
        
        // Rotate 90 degrees
        moveRobot(0.0, 0.0, 1.0, 150);
        delay(1000);
        stopAllMotors();
        
        Serial.print("Rotation (degrees): ");
        Serial.println((theta - startTheta) * 180/PI);
    }
    
    void testAprilTag() {
        int testDuration = 30; // seconds
        unsigned long startTime = millis();
        
        while(millis() - startTime < testDuration * 1000) {
            if(tagDetected) {
                Serial.print("Tag detected - ID: ");
                Serial.print(tagID);
                Serial.print(" X: ");
                Serial.print(tagX);
                Serial.print(" Z: ");
                Serial.println(tagZ);
            }
            checkSerialForTag();
            delay(100);
        }
    }
};
\end{lstlisting}

The alpha testing implementation provided structured validation of:
\begin{itemize}
    \item Individual motor control and timing
    \item Sensor accuracy and reliability
    \item Encoder count verification
    \item IMU heading accuracy
    \item AprilTag detection reliability
\end{itemize}

\subsection{Final implementation}
Building on the successful alpha tests, the final implementation integrates all components into a robust control system:

\begin{lstlisting}[language=C, basicstyle=\ttfamily\footnotesize, frame=single, xleftmargin=10mm, xrightmargin=10mm]
class RobotController {
public:
    enum OperationMode {
        MANUAL,
        AUTONOMOUS,
        TAG_FOLLOWING,
        CHARGING
    };

    RobotController() : currentMode(MANUAL) {
        setupHardware();
        calibrateSensors();
    }

    void run() {
        while(true) {
            updateSensors();
            processCommands();
            updateState();
            controlLoop();
            reportStatus();
            delay(50); // 20Hz update rate
        }
    }

private:
    OperationMode currentMode;
    bool emergencyStopped = false;
    unsigned long lastUpdate = 0;
    
    void setupHardware() {
        // Initialize all pins
        setupMotors();
        setupSensors();
        setupCommunication();
        
        Serial.println("Hardware initialization complete");
    }
    
    void calibrateSensors() {
        // Zero encoders
        leftEncoderCount = 0;
        rightEncoderCount = 0;
        
        // Calibrate IMU
        imu.calibrateGyro();
        
        // Reset position
        x_pos = 0.0;
        y_pos = 0.0;
        theta = 0.0;
    }
    
    void updateSensors() {
        updateDistances();   // Ultrasonic sensors
        updatePosition();    // Encoders
        updateIMUData();    // IMU
        checkSerialForTag(); // AprilTag
    }
    
    void processCommands() {
        if(Serial.available()) {
            char cmd = Serial.read();
            switch(cmd) {
                case 'M': currentMode = MANUAL; break;
                case 'A': currentMode = AUTONOMOUS; break;
                case 'T': currentMode = TAG_FOLLOWING; break;
                case 'C': currentMode = CHARGING; break;
                case 'E': emergencyStop(); break;
                case 'R': resetEmergencyStop(); break;
            }
        }
    }
    
    void updateState() {
        unsigned long now = millis();
        float dt = (now - lastUpdate) / 1000.0;
        lastUpdate = now;
        
        // Update localization with sensor fusion
        updateLocalization(dt);
        
        // Check for obstacles
        checkObstacles();
    }
    
    void controlLoop() {
        if(emergencyStopped) {
            stopAllMotors();
            return;
        }
        
        switch(currentMode) {
            case MANUAL:
                handleManualControl();
                break;
                
            case AUTONOMOUS:
                handleAutonomousMode();
                break;
                
            case TAG_FOLLOWING:
                handleTagFollowing();
                break;
                
            case CHARGING:
                handleChargingMode();
                break;
        }
    }
    
    void handleManualControl() {
        if(Serial.available() >= 3) {
            float vx = (Serial.read() - 128) / 128.0;
            float vy = (Serial.read() - 128) / 128.0;
            float omega = (Serial.read() - 128) / 128.0;
            moveRobot(vx, vy, omega);
        }
    }
    
    void handleAutonomousMode() {
        // Simple obstacle avoidance
        if(obstacleDetected()) {
            avoidObstacle();
        } else {
            // Continue on path or exploration
            moveRobot(-1.0, 0.0, 0.0);
        }
    }
    
    void handleTagFollowing() {
        if(tagDetected) {
            // Proportional control to follow tag
            float angularCorrection = tagX * 2.0;
            moveRobot(-0.8, 0.0, angularCorrection);
        } else {
            // Search pattern when tag lost
            moveRobot(0.0, 0.0, 0.5);
        }
    }
    
    void handleChargingMode() {
        if(atChargingStation()) {
            stopAllMotors();
            // Enable charging circuit
        } else if(tagDetected && tagID == CHARGING_TAG_ID) {
            approachChargingStation();
        } else {
            searchForChargingStation();
        }
    }
    
    void reportStatus() {
        // Send status over Serial every 500ms
        static unsigned long lastReport = 0;
        if(millis() - lastReport > 500) {
            sendStatusReport();
            lastReport = millis();
        }
    }
};

// Main program
RobotController robot;

void setup() {
    Serial.begin(115200);
    Wire.begin();
    robot = RobotController();
}

void loop() {
    robot.run();
}
\end{lstlisting}

The final implementation provides:
\begin{itemize}
    \item Multiple operation modes (manual, autonomous, tag following, charging)
    \item Robust sensor fusion for localization
    \item Emergency stop functionality
    \item Modular control architecture
    \item Regular status reporting
    \item Efficient 20Hz control loop
\end{itemize}

The system proved reliable in testing with:
\begin{itemize}
    \item Autonomous operation for 3+ hours
    \item Successful navigation through dynamic environments
    \item Reliable AprilTag-based docking
    \item Smooth transitions between operation modes
\end{itemize}

\newpage
\section{Bill of Materials}
\begin{table}[ht]
\centering
\begin{tabular}{|>{\raggedright\arraybackslash}p{4cm}|>{\raggedright\arraybackslash}p{3cm}|>{\raggedright\arraybackslash}p{6cm}|c|}
\hline
\textbf{COMPONENT} & \textbf{FUNCTION} & \textbf{MODEL} & \textbf{QUANTITY} \\ \hline
DC Motor & Robot movement & JGB37-520 Encoder Hall DC motor (178 RPM, 1.8 Nm torque) & 3 \\ \hline
Motor Driver & Motor control interface & BTS7960 43A H-bridge & 3 \\ \hline
Shaft Coupling & Wheel-motor connection & 6mm shaft coupling & 4 \\ \hline
Omni Wheels & Holonomic movement & 58mm Nylon Omni wheels & 4 \\ \hline
Jumper Wires & Component connections & 40PIN 20cm Dupont wires (M-M, F-F) & 1 set \\ \hline
Structure Material & Internal framework & MDF panel (220 x 152 cm, 3mm) & 1 \\ \hline
Ultrasonic Sensors & Distance measurement & HC-SR04 & 6 \\ \hline
\end{tabular}
\caption{Component List and Specifications}
\label{tab:components}
\end{table}

\section{Design and Implementation Challenges}
During the development of this project, we encountered several technical challenges:

\begin{itemize}
\item Integration of motor encoders with the control system
\item Achieving reliable distance measurements from the HC-SR04 sensors
\item Implementation of smooth holonomic movement
\item Motor control synchronization
\end{itemize}

\newpage
\section{Photo gallery}
\noindent
\begin{minipage}[t]{0.5\textwidth}
  \vspace{0pt}
  \includegraphics[width=0.9\linewidth]{photos/1.jpg}
  \captionof{figure}{three-wheel Omnidirectional}
  \vspace{0pt}
  \includegraphics[width=0.9\linewidth]{photos/3.jpg}
  \captionof{figure}{three-wheel Omnidirectional}
\end{minipage}
\hfill
\begin{minipage}[t]{0.5\textwidth}
    \vspace{0pt}
    \includegraphics[width=0.9\linewidth]{photos/2.jpg}
  \captionof{figure}{three-wheel Omnidirectional}
  \vspace{0pt}
  \includegraphics[width=0.9\linewidth]{photos/4.jpg}
  \captionof{figure}{three-wheel Omnidirectional}
 \end{minipage}

\newpage
\noindent
\begin{minipage}[t]{0.5\textwidth}
  \vspace{0pt}
  \vspace{0pt}
  \includegraphics[width=0.9\linewidth]{photos/5.jpg}
  \captionof{figure}{three-wheel Omnidirectional}
  \vspace{0pt}
  \includegraphics[width=0.9\linewidth]{photos/9.jpg}
  \captionof{figure}{three-wheel Omnidirectional}
\end{minipage}
\hfill
\begin{minipage}[t]{0.5\textwidth}
\vspace{0pt}
  \includegraphics[width=0.9\linewidth]{photos/6.jpg}
  \captionof{figure}{three-wheel Omnidirectional}
  \vspace{0pt}
  \includegraphics[width=0.9\linewidth]{photos/dani_fixing_robot.jpeg}
  \captionof{figure}{three-wheel Omnidirectional}
\end{minipage}


\newpage
\section{Testing}
\subsection{Testing Methodology}
Our testing phase was divided into three main categories:

\begin{enumerate}
    \item \textbf{Component Testing} - Individual validation of sensors and motors
    \item \textbf{Integration Testing} - Combined operation of multiple components
    \item \textbf{System Testing} - Full robot operation in various scenarios
\end{enumerate}

\subsection{Sensor Testing}
We implemented comprehensive testing routines for the HC-SR04 ultrasonic sensors:

\begin{itemize}
    \item \textbf{Individual Sensor Tests}: Each of the six sensors was tested independently
    \item \textbf{Continuous Reading Tests}: Multiple readings over time to assess consistency
    \item \textbf{Proximity Warning Tests}: Verification of obstacle detection thresholds
    \item \textbf{Reliability Tests}: Statistical analysis of sensor accuracy
\end{itemize}

Results showed reliable readings between 2cm and 400cm, with accuracy diminishing beyond this range. The implementation included timeout handling and error checking:

\begin{lstlisting}[language=C, basicstyle=\ttfamily\footnotesize, frame=single]
void testSensorReliability() {
    for (int i = 0; i < 6; i++) {
        int validReadings = 0;
        int totalReadings = 10;

        for (int j = 0; j < totalReadings; j++) {
            long distance = readDistance(*sensors[i]);
            if (distance > 0 && distance <= MAX_DISTANCE) {
                validReadings++;
            }
        }

        float reliability = (validReadings * 100.0) / totalReadings;
        // Reliability scores typically exceeded 95% in optimal conditions
    }
}
\end{lstlisting}

\subsection{Motor Testing}
The holonomic drive system underwent rigorous testing:

\begin{itemize}
    \item \textbf{Individual Motor Control}: Testing forward/reverse operation
    \item \textbf{Combined Movement Patterns}: Verifying holonomic motion capabilities
    \item \textbf{Speed Control}: PWM signal validation
    \item \textbf{Emergency Stop}: Response time testing
\end{itemize}

Movement testing included eight primary directions plus rotation:

\begin{lstlisting}[language=C, basicstyle=\ttfamily\footnotesize, frame=single]
void testMovementPatterns() {
    // Forward
    moveRobot(-1.0, 0.0, 0.0);
    // Right
    moveRobot(0.0, 1.0, 0.0);
    // Diagonal Forward-Right
    moveRobot(-0.7, 0.7, 0.0);
    // Rotation
    moveRobot(0.0, 0.0, 1.0);
    // Combined Movement
    moveRobot(-0.5, 0.5, 0.2);
}
\end{lstlisting}

\subsection{Integration Testing Results}
Combined testing revealed several key insights:

\begin{enumerate}
    \item \textbf{Sensor Interference}: No significant cross-talk between ultrasonic sensors when properly timed
    \item \textbf{Motor Impact}: Motor vibration had minimal effect on sensor readings
    \item \textbf{Response Time}: Average system response to obstacles was under 100ms
    \item \textbf{Positioning Accuracy}: Achieved positioning accuracy of ±5mm in controlled conditions
\end{enumerate}

\subsection{System Performance Metrics}
Final system testing yielded the following performance metrics:

\begin{itemize}
    \item \textbf{Maximum Safe Speed}: 0.5 m/s
    \item \textbf{Minimum Obstacle Distance}: 15cm
    \item \textbf{Rotation Accuracy}: ±2 degrees
    \item \textbf{Position Hold}: ±1cm when stationary
    \item \textbf{Battery Life}: 3+ hours continuous operation
\end{itemize}

\subsection{Difficulties and Limitations}
During our testing phase, we encountered several challenges and limitations:

\subsubsection{Sensor Limitations}
\begin{itemize}
    \item \textbf{HC-SR04 Angular Range}: The ultrasonic sensors showed reduced accuracy at angles greater than ±15° from perpendicular
    \item \textbf{Surface Reflectivity}: Certain surface materials caused unreliable readings due to sound absorption or scattered reflections
    \item \textbf{Environmental Factors}: Air temperature and humidity variations affected sensor accuracy by approximately ±1\% per °C
\end{itemize}

\subsubsection{Motor Control Challenges}
\begin{itemize}
    \item \textbf{Synchronization}: Achieving perfectly synchronized motor movement required careful PWM timing adjustments
    \item \textbf{Dead Zone}: Motors showed non-linear response below 10\% PWM duty cycle
    \item \textbf{Mechanical Backlash}: Gear reduction in motors introduced ~2° of backlash, affecting precise positioning
\end{itemize}

\subsubsection{Smooth Deceleration System}
Our implementation of smooth deceleration presented unique challenges and solutions:

\begin{itemize}
    \item \textbf{Direction Tracking}: Maintaining direction information during deceleration required global variable coordination between modules
    \item \textbf{Rate Control}: We determined a deceleration rate of 0.15 per cycle provided optimal balance between smoothness and responsiveness
    \item \textbf{Safety Integration}: The system required careful coordination with emergency stop procedures to ensure safety wasn't compromised
    \item \textbf{File Structure}: Code modularization necessitated proper extern declarations and variable sharing between files
\end{itemize}

\begin{lstlisting}[language=C, basicstyle=\ttfamily\footnotesize, frame=single, xleftmargin=10mm, xrightmargin=10mm]
// Direction tracking implementation
Direction leftDir = STOP;  // Direction tracking for left motor
Direction rightDir = STOP; // Direction tracking for right motor
Direction backDir = STOP;  // Direction tracking for back motor

// Core deceleration function
bool smoothDecelerateMotor(Motor &motor, Direction currentDir) {
    // Calculate new speed with smooth deceleration
    float newSpeed = max(0, motor.currentSpeed - (MAX_SPEED * decelerationRate));
    motor.currentSpeed = newSpeed;
    
    // Apply PWM based on tracked direction
    switch (currentDir) {
    case FORWARD:
        analogWrite(motor.RPWM, speedInt);
        analogWrite(motor.LPWM, 0);
        break;
    case BACKWARD:
        analogWrite(motor.RPWM, 0);
        analogWrite(motor.LPWM, speedInt);
        break;
    case STOP:
        // Do nothing - already stopped
        break;
    }
    
    return (motor.currentSpeed <= 0);
}
\end{lstlisting}

\subsubsection{Movement Constraints}
\begin{itemize}
    \item \textbf{Surface Dependency}: Omni-wheel performance varied significantly based on floor texture and cleanliness
    \item \textbf{Speed vs. Stability}: Speeds above 0.5 m/s led to increased wheel slip and reduced position accuracy
    \item \textbf{Load Distribution}: Uneven weight distribution affected straight-line movement accuracy
\end{itemize}

\subsubsection{Power Management}
\begin{itemize}
    \item \textbf{Voltage Sag}: High-current motor operations caused voltage fluctuations affecting sensor readings
    \item \textbf{Heat Management}: Extended operation required monitoring of motor driver temperature
    \item \textbf{Battery Life}: Continuous movement reduced operational time to approximately 2 hours
\end{itemize}

These limitations informed our final design choices and operating parameters, leading to the implementation of various compensatory measures in both hardware and software.

\newpage
\section{Possible Future Improvements}
Based on our testing results and identified limitations, we propose several potential improvements for future iterations:

\subsection{Sensor Enhancements}
\begin{itemize}
    \item \textbf{Additional Sensor Types}:
        \begin{itemize}
            \item Integration of Time-of-Flight (ToF) sensors for more accurate distance measurements
            \item Addition of IR proximity sensors for redundancy and improved obstacle detection
            \item Implementation of a 360° LIDAR for comprehensive environment mapping
        \end{itemize}
    
    \item \textbf{Sensor Fusion Improvements}:
        \begin{itemize}
            \item Implementation of Extended Kalman Filter (EKF) for better sensor data integration
            \item Development of adaptive filtering based on sensor confidence levels
            \item Integration of visual SLAM for enhanced localization accuracy
        \end{itemize}
\end{itemize}

\subsection{Motor Control Optimization}
\begin{itemize}
    \item \textbf{Advanced Control Algorithms}:
        \begin{itemize}
            \item Implementation of PID control for each motor
            \item Development of model predictive control (MPC) for smoother trajectories
            \item Integration of adaptive control to handle varying loads
        \end{itemize}
    
    \item \textbf{Mechanical Improvements}:
        \begin{itemize}
            \item Design of custom gear reduction to minimize backlash
            \item Implementation of active suspension for better traction
            \item Development of auto-calibration routines for wheel alignment
        \end{itemize}
\end{itemize}

\subsection{Power Management}
\begin{itemize}
    \item \textbf{Energy Efficiency}:
        \begin{itemize}
            \item Implementation of dynamic power scaling based on load
            \item Development of regenerative braking capabilities
            \item Integration of smart sleep modes for idle periods
        \end{itemize}
    
    \item \textbf{Power System Upgrades}:
        \begin{itemize}
            \item Addition of voltage regulation for sensitive components
            \item Implementation of active thermal management
            \item Integration of wireless charging capabilities
        \end{itemize}
\end{itemize}

\subsection{Software Architecture}
\begin{itemize}
    \item \textbf{Code Optimization}:
        \begin{itemize}
            \item Migration to a real-time operating system (RTOS)
            \item Implementation of multi-threading for parallel sensor processing
            \item Development of modular firmware architecture
        \end{itemize}
    
    \item \textbf{Navigation Improvements}:
        \begin{itemize}
            \item Integration of path planning algorithms
            \item Implementation of dynamic obstacle avoidance
            \item Development of behavioral navigation modes
        \end{itemize}
\end{itemize}

\subsection{User Interface}
\begin{itemize}
    \item \textbf{Monitoring and Control}:
        \begin{itemize}
            \item Development of web-based control interface
            \item Implementation of real-time telemetry visualization
            \item Integration of remote diagnostics capabilities
        \end{itemize}
    
    \item \textbf{Configuration Management}:
        \begin{itemize}
            \item Creation of user-friendly calibration interfaces
            \item Development of parameter tuning tools
            \item Implementation of configuration backup/restore features
        \end{itemize}
\end{itemize}

These improvements would enhance the robot's capabilities while addressing the current limitations identified during testing. Implementation priority should be based on specific application requirements and available resources.

\newpage
\section{Final considerations}

\subsection{Localization Implementation}
The following code demonstrates our sensor fusion approach for robot localization, combining data from wheel encoders, an IMU (MPU6050), and AprilTag detections:

\begin{lstlisting}[language=C, basicstyle=\ttfamily\footnotesize, frame=single, xleftmargin=10mm, xrightmargin=10mm]
// Robot physical parameters
#define WHEEL_DIAMETER 65.0        // in mm
#define WHEEL_BASE 150.0          // distance between wheels in mm
#define TICKS_PER_REVOLUTION 1120 // encoder ticks per wheel revolution

// Position and orientation tracking
float x_pos = 0.0;
float y_pos = 0.0;
float theta = 0.0; // radians

void updatePosition() {
    long leftCount = leftEncoderCount;
    long rightCount = rightEncoderCount;
    
    long deltaLeft = leftCount - prevLeftCount;
    long deltaRight = rightCount - prevRightCount;
    
    prevLeftCount = leftCount;
    prevRightCount = rightCount;
    
    // Calculate distance moved by each wheel
    float distanceLeft = (PI * WHEEL_DIAMETER) * 
                        (deltaLeft / (float)TICKS_PER_REVOLUTION);
    float distanceRight = (PI * WHEEL_DIAMETER) * 
                         (deltaRight / (float)TICKS_PER_REVOLUTION);
    float distanceCenter = (distanceLeft + distanceRight) / 2.0;
    
    // Update position based on heading
    x_pos += distanceCenter * cos(theta);
    y_pos += distanceCenter * sin(theta);
}

void updateIMUData() {
    Vector norm = imu.readNormalizeGyro();
    float gyroZ = norm.ZAxis;
    float dt = IMU_UPDATE_INTERVAL / 1000.0;
    theta += gyroZ * dt;  // integrate gyro data
    
    // Keep theta within -PI to +PI
    if (theta > PI) theta -= 2 * PI;
    if (theta < -PI) theta += 2 * PI;
}

// AprilTag data processing
void parseTagData(String data) {
    // Parse comma-separated tag data: id,x,y,yaw
    int firstComma = data.indexOf(',');
    int secondComma = data.indexOf(',', firstComma + 1);
    int thirdComma = data.indexOf(',', secondComma + 1);
    
    if (firstComma > 0 && secondComma > firstComma && 
        thirdComma > secondComma) {
        int id = data.substring(0, firstComma).toInt();
        tagX = data.substring(firstComma + 1, secondComma).toFloat();
        tagY = data.substring(secondComma + 1, thirdComma).toFloat();
        tagYaw = data.substring(thirdComma + 1).toFloat();
        tagDetected = true;
    }
}
\end{lstlisting}

This implementation includes:
\begin{itemize}
    \item Wheel encoder-based odometry for position tracking
    \item IMU integration for improved heading estimation
    \item AprilTag detection processing for absolute position corrections
    \item Basic sensor fusion using complementary filtering
\end{itemize}

Key features:
\begin{itemize}
    \item High-resolution encoder readings (1120 ticks/revolution)
    \item Real-time IMU data integration at 50Hz (20ms intervals)
    \item Position updates at 10Hz (100ms intervals)
    \item AprilTag-based position correction when markers are detected
\end{itemize}

Testing validated:
\begin{itemize}
    \item Position accuracy within ±5mm in controlled conditions
    \item Heading accuracy within ±2 degrees with IMU fusion
    \item Successful drift correction using AprilTag detections
    \item Reliable operation at speeds up to 0.5 m/s
\end{itemize}

\newpage
\section{Testing Conclusions}
Our comprehensive testing phase yielded valuable insights into both the capabilities and limitations of our implementation:

\subsubsection{Achievements}
\begin{itemize}
    \item Successfully implemented and validated a fully functional holonomic drive system
    \item Achieved reliable obstacle detection and avoidance using multiple ultrasonic sensors
    \item Demonstrated stable multi-mode operation (manual, autonomous, tag following, charging)
    \item Established robust communication between system components
\end{itemize}

\subsubsection{Lessons Learned}
\begin{itemize}
    \item Early component testing is crucial for identifying potential integration issues
    \item Sensor calibration significantly impacts overall system reliability
    \item Environmental factors must be carefully considered in sensor placement and configuration
    \item Regular validation of sensor fusion algorithms is essential for maintaining accuracy
\end{itemize}

\subsubsection{Design Validation}
The testing phase validated our core design decisions:
\begin{itemize}
    \item Three-wheel omni configuration proved sufficient for intended use cases
    \item Selected motor specifications met movement requirements
    \item Sensor arrangement provided adequate coverage for obstacle detection
    \item Control architecture supported all required operational modes
\end{itemize}

\subsubsection{Development Impact}
Testing results directly influenced several design refinements:
\begin{itemize}
    \item Implementation of inter-file direction tracking for the smooth deceleration system
    \item Addition of global direction variables (leftDir, rightDir, backDir) to track motor states
    \item Improved coordination between movement control and deceleration modules
    \item Better error handling for unexpected motor states during transitions
    \item Enhanced safety mechanisms to prevent compiler errors from affecting critical operations
\end{itemize}

\subsubsection{Integration Challenges}
The most valuable lessons emerged from resolving integration challenges:
\begin{itemize}
    \item Proper inter-file variable declarations proved critical for system stability
    \item Motor direction tracking required synchronized access across multiple code files
    \item Emergency stop functionality needed careful coordination with smooth deceleration
    \item Object avoidance systems required coordinated access to motor control
\end{itemize}

The smooth deceleration system in particular highlighted the importance of proper variable scope and declaration. By implementing global direction tracking variables with proper extern declarations, we resolved undefined reference errors and achieved seamless coordination between the movement control system and deceleration processes.
